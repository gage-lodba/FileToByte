/*
 * This is a modified version of binary_to_compressed_c.cpp
 * from the imgui library see:
 * https://github.com/ocornut/imgui/tree/master/misc/fonts
 */
#include "FTB.hpp"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include <cstring>
#include <fstream>
#include <iomanip>
#include <ios>
#include <sstream>
#include <string>
#include <vector>

typedef unsigned int stb_uint;
typedef unsigned char stb_uchar;
stb_uint stb_compress(stb_uchar *out, stb_uchar *in, stb_uint len);

std::string Convert(std::string file_path, std::string array_name) {
  std::ifstream file(file_path, std::ios::in | std::ios::binary);

  if (!file.is_open())
    return "File failed to open";

  file.seekg(0, std::ios::end);
  std::streamsize data_sz = file.tellg();
  file.seekg(0, std::ios::beg);

  if (data_sz == -1) {
    return "";
  }

  std::vector<char> data(data_sz + 4);
  if (!file.read(data.data(), data_sz)) {
    return "";
  }

  memset(data.data() + data_sz, 0, 4);

  int maxlen = data_sz + 512 + (data_sz >> 2) + sizeof(int);
  std::vector<char> compressed(maxlen);
  int compressed_sz = stb_compress(
      reinterpret_cast<stb_uchar *>(compressed.data()),
      reinterpret_cast<stb_uchar *>(data.data()), static_cast<int>(data_sz));

  memset(compressed.data() + compressed_sz, 0, maxlen - compressed_sz);

  std::ostringstream stream;

  stream << "#pragma once\n\n";
  stream << "/*\n";
  stream << " *\tGenerated by File To Byte\n";
  stream << " *\thttps://github.com/gage-lodba/FileToByte\n";
  stream << " */\n\n";
  stream << "static const unsigned int " << array_name
         << "_compressed_size = " << (int)compressed_sz << ";\n";
  stream << "static const unsigned int " << array_name << "_compressed_data["
         << (int)((compressed_sz + 3) / 4) * 4 << " / 4] = {";

  int column = 0;
  for (int i = 0; i < compressed_sz; i += 4) {
    unsigned int d = *reinterpret_cast<unsigned int *>(compressed.data() + i);
    if ((column++ % 8) == 0)
      stream << "\n\t0x" << std::hex << std::setw(8) << std::setfill('0') << d
             << ", ";
    else
      stream << "0x" << std::hex << std::setw(8) << std::setfill('0') << d
             << ", ";
  }
  stream << "\n};\n";

  return stream.str();
}

// stb_compress* from stb.h - definition

////////////////////           compressor         ///////////////////////

static stb_uint stb_adler32(stb_uint adler32, stb_uchar *buffer,
                            stb_uint buflen) {
  const unsigned long ADLER_MOD = 65521;
  unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
  unsigned long blocklen, i;

  blocklen = buflen % 5552;
  while (buflen) {
    for (i = 0; i + 7 < blocklen; i += 8) {
      s1 += buffer[0], s2 += s1;
      s1 += buffer[1], s2 += s1;
      s1 += buffer[2], s2 += s1;
      s1 += buffer[3], s2 += s1;
      s1 += buffer[4], s2 += s1;
      s1 += buffer[5], s2 += s1;
      s1 += buffer[6], s2 += s1;
      s1 += buffer[7], s2 += s1;

      buffer += 8;
    }

    for (; i < blocklen; ++i)
      s1 += *buffer++, s2 += s1;

    s1 %= ADLER_MOD, s2 %= ADLER_MOD;
    buflen -= blocklen;
    blocklen = 5552;
  }
  return (s2 << 16) + s1;
}

static unsigned int stb_matchlen(stb_uchar *m1, stb_uchar *m2,
                                 stb_uint maxlen) {
  stb_uint i;
  for (i = 0; i < maxlen; ++i)
    if (m1[i] != m2[i])
      return i;
  return i;
}

static stb_uchar *stb__out;
static FILE *stb__outfile;
static stb_uint stb__outbytes;

static void stb__write(unsigned char v) {
  fputc(v, stb__outfile);
  ++stb__outbytes;
}

#define stb_out(v)                                                             \
  do {                                                                         \
    if (stb__out)                                                              \
      *stb__out++ = (stb_uchar)(v);                                            \
    else                                                                       \
      stb__write((stb_uchar)(v));                                              \
  } while (0)

static void stb_out2(stb_uint v) {
  stb_out(v >> 8);
  stb_out(v);
}
static void stb_out3(stb_uint v) {
  stb_out(v >> 16);
  stb_out(v >> 8);
  stb_out(v);
}
static void stb_out4(stb_uint v) {
  stb_out(v >> 24);
  stb_out(v >> 16);
  stb_out(v >> 8);
  stb_out(v);
}

static void outliterals(stb_uchar *in, int numlit) {
  while (numlit > 65536) {
    outliterals(in, 65536);
    in += 65536;
    numlit -= 65536;
  }

  if (numlit == 0)
    ;
  else if (numlit <= 32)
    stb_out(0x000020 + numlit - 1);
  else if (numlit <= 2048)
    stb_out2(0x000800 + numlit - 1);
  else
    stb_out3(0x070000 + numlit - 1);

  if (stb__out) {
    memcpy(stb__out, in, numlit);
    stb__out += numlit;
  } else
    fwrite(in, 1, numlit, stb__outfile);
}

static int stb__window = 0x40000;

static int stb_not_crap(int best, int dist) {
  return ((best > 2 && dist <= 0x00100) || (best > 5 && dist <= 0x04000) ||
          (best > 7 && dist <= 0x80000));
}

static stb_uint stb__hashsize = 32768;

#define stb__hc(q, h, c) (((h) << 7) + ((h) >> 25) + q[c])
#define stb__hc2(q, h, c, d) (((h) << 14) + ((h) >> 18) + (q[c] << 7) + q[d])
#define stb__hc3(q, c, d, e) ((q[c] << 14) + (q[d] << 7) + q[e])

static unsigned int stb__running_adler;

static int stb_compress_chunk(stb_uchar *history, stb_uchar *start,
                              stb_uchar *end, int length, int *pending_literals,
                              stb_uchar **chash, stb_uint mask) {
  (void)history;
  int window = stb__window;
  stb_uint match_max;
  stb_uchar *lit_start = start - *pending_literals;
  stb_uchar *q = start;

#define STB__SCRAMBLE(h) (((h) + ((h) >> 16)) & mask)

  while (q < start + length && q + 12 < end) {
    int m;
    stb_uint h1, h2, h3, h4, h;
    stb_uchar *t;
    int best = 2, dist = 0;

    if (q + 65536 > end)
      match_max = (stb_uint)(end - q);
    else
      match_max = 65536;

#define stb__nc(b, d)                                                          \
  ((d) <= window && ((b) > 9 || stb_not_crap((int)(b), (int)(d))))

#define STB__TRY(t, p)                                                         \
  if (p ? dist != (int)(q - t) : 1)                                            \
    if ((m = stb_matchlen(t, q, match_max)) > best)                            \
      if (stb__nc(m, q - (t)))                                                 \
  best = m, dist = (int)(q - (t))

    h = stb__hc3(q, 0, 1, 2);
    h1 = STB__SCRAMBLE(h);
    t = chash[h1];
    if (t)
      STB__TRY(t, 0);
    h = stb__hc2(q, h, 3, 4);
    h2 = STB__SCRAMBLE(h);
    h = stb__hc2(q, h, 5, 6);
    t = chash[h2];
    if (t)
      STB__TRY(t, 1);
    h = stb__hc2(q, h, 7, 8);
    h3 = STB__SCRAMBLE(h);
    h = stb__hc2(q, h, 9, 10);
    t = chash[h3];
    if (t)
      STB__TRY(t, 1);
    h = stb__hc2(q, h, 11, 12);
    h4 = STB__SCRAMBLE(h);
    t = chash[h4];
    if (t)
      STB__TRY(t, 1);

    chash[h1] = chash[h2] = chash[h3] = chash[h4] = q;

    if (best > 2)
      assert(dist > 0);

    if (best < 3) {
      ++q;
    } else if (best > 2 && best <= 0x80 && dist <= 0x100) {
      outliterals(lit_start, (int)(q - lit_start));
      lit_start = (q += best);
      stb_out(0x80 + best - 1);
      stb_out(dist - 1);
    } else if (best > 5 && best <= 0x100 && dist <= 0x4000) {
      outliterals(lit_start, (int)(q - lit_start));
      lit_start = (q += best);
      stb_out2(0x4000 + dist - 1);
      stb_out(best - 1);
    } else if (best > 7 && best <= 0x100 && dist <= 0x80000) {
      outliterals(lit_start, (int)(q - lit_start));
      lit_start = (q += best);
      stb_out3(0x180000 + dist - 1);
      stb_out(best - 1);
    } else if (best > 8 && best <= 0x10000 && dist <= 0x80000) {
      outliterals(lit_start, (int)(q - lit_start));
      lit_start = (q += best);
      stb_out3(0x100000 + dist - 1);
      stb_out2(best - 1);
    } else if (best > 9 && dist <= 0x1000000) {
      if (best > 65536)
        best = 65536;
      outliterals(lit_start, (int)(q - lit_start));
      lit_start = (q += best);
      if (best <= 0x100) {
        stb_out(0x06);
        stb_out3(dist - 1);
        stb_out(best - 1);
      } else {
        stb_out(0x04);
        stb_out3(dist - 1);
        stb_out2(best - 1);
      }
    } else {
      ++q;
    }
  }

  if (q - start < length)
    q = start + length;

  *pending_literals = (int)(q - lit_start);

  stb__running_adler =
      stb_adler32(stb__running_adler, start, (stb_uint)(q - start));
  return (int)(q - start);
}

static int stb_compress_inner(stb_uchar *input, stb_uint length) {
  int literals = 0;
  stb_uint len, i;

  stb_uchar **chash;
  chash = (stb_uchar **)malloc(stb__hashsize * sizeof(stb_uchar *));
  if (chash == nullptr)
    return 0; // failure
  for (i = 0; i < stb__hashsize; ++i)
    chash[i] = nullptr;

  // stream signature
  stb_out(0x57);
  stb_out(0xbc);
  stb_out2(0);

  stb_out4(0); // 64-bit length requires 32-bit leading 0
  stb_out4(length);
  stb_out4(stb__window);

  stb__running_adler = 1;

  len = stb_compress_chunk(input, input, input + length, length, &literals,
                           chash, stb__hashsize - 1);
  assert(len == length);

  outliterals(input + length - literals, literals);

  free(chash);

  stb_out2(0x05fa); // end opcode

  stb_out4(stb__running_adler);

  return 1; // success
}

stb_uint stb_compress(stb_uchar *out, stb_uchar *input, stb_uint length) {
  stb__out = out;
  stb__outfile = nullptr;

  stb_compress_inner(input, length);

  return (stb_uint)(stb__out - out);
}
